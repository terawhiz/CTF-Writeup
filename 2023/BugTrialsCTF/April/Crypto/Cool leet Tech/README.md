# Cool leet Tech - 175 Points

Description:
```I built some cool leet tech to encrypt my secrets with. I'm so confident it's unbreakable, that I'm even going to give you the source code and my encrypted secrets.```

## Solution:

This program generates two large prime numbers using getPrime, calculates their product, and then encrypts a given flag using the generated public key. The encryption is done using RSA encryption, a widely used public-key encryption algorithm.

```py
import random
from tqdm import tqdm
from Crypto.Util.number import bytes_to_long, getPrime, isPrime

def rng_initializer():
    seed = 0
    for i in tqdm(range(1000000000)):
        seed += random.randint(0, random.randint(0, random.randint(0, random.randint(0, 10))))
    rng = random.Random(seed)
    return rng


def find_primes(rng):
    p = 0
    q = 0
    while p == q:
        while not isPrime(p):
            p = getPrime(256, randfunc=lambda n: rng.getrandbits(n).to_bytes((n+7)//8, 'big'))
        while not isPrime(q):
            q = getPrime(256, randfunc=lambda n: rng.getrandbits(n).to_bytes((n+7)//8, 'big'))    
    return p, q


def encrypt(m: bytes, p: int, q: int, e: int) -> int:
    n = p * q
    m = bytes_to_long(m)
    enc = pow(m, e, n)
    return enc


if __name__ == '__main__':
    rng = rng_initializer()
    p, q = find_primes(rng)
    e = 65537
    flag = open('flag.txt', 'rb').read()
    enc = encrypt(flag, p, q, e)
    with open("output.txt", "w") as f:
        f.write(f"{enc=}")
```

The `find_primes` function generates two prime numbers `p` and `q` of `256 bits` each using the `getPrime` function from the Crypto.Util.number module.

The `getPrime` function uses the `randfunc` parameter to generate random numbers and test them for primality until it finds a prime. In this code, the `randfunc` parameter is set to a lambda function that generates random bits using the `rng.getrandbits` method, which is itself seeded with a random value generated by the `rng_initializer` function.

The while loop in find_primes ensures that `p` and `q` are not equal to each other.

From here I had no idea on how to solve the challenge. Except I know we need to find `p` and `q` to calculate `d`. By running the `enc.py` script a couple of times I noticed the seed value was always in the range of `624900000` - `625000000`. So I wrote a quick script to bruteforce the seed value, by running that script we can get the flag in couple of minutes.

Exploit: [Link](./hack.py)